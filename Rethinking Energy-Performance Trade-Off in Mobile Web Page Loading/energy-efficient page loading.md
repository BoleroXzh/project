在本节中，我们将介绍旨在更好地平衡移动网页加载中的能源成本和性能的三种技术。 我们精心设计技术来控制其对页面加载时间的影响。

## Network-AwareWeb资源处理

选择多久进行网络资源处理会影响性能和能效。频繁的资源处理可能伴随着能源效率低下，因为它可以产生边际进展，同时消耗大量的能源。如3.1所示，渲染器进程可以对每个少量数据（例如，以2Mbps下载速度少于3KB）进行网络资源处理。这意味着需要对网络资源进行批处理，以提高成本效益。但是，这可能会延迟Web资源的处理并增加页面加载时间。例如，HTML资源通常包含指向其他网络资源（如图像和JavaScript库）的链接。虽然渲染器进程延迟了HTML资源的处理，但浏览器进程无法继续从网络下载嵌入式资源。所以它需要一个好的策略来合并资源以进行高效节能的资源处理，同时不会增加页面加载时间。

为此，我们建议设计适应网络资源下载速度的网络资源处理，我们称之为网络感知资源处理（NRP）。一个基本的基本原则是更快的下载，更大的批量以获得更好的能效。也就是说，我们的批量较小，下载速度较慢，以免在Web资源处理中引入过多的延迟。我们强制浏览器进程缓冲从网络接收到的数据，并且只有在缓冲数据量大于阈值时才通知渲染器进程。这样，我们可以减少网络资源处理的次数以及涉及的IPC数量，从而可以降低能源成本。

为了平衡资源处理延迟和能源效率之间的平衡，我们设计缓冲区阈值buf_threshold和总缓冲区大小buf_size以适应资源下载速度net_goodput，如下所示。

buf_threshold = α ∗ net_goodput 

buf_size = β ∗ buf_threshold,

其中net_goodput是使用指数加权移动平均线（EWMA）估算的，这是一个基于线性历史的估计器，其平滑因子为0.3，如[25,32]中所述。参数α表示一段数据在缓冲区中可以经历的最大等待时间，并且被设置为0.5秒，在此处我们在节能和资源处理延迟之间找到平衡。参数β控制总缓冲区大小。缓冲器过度使用时会增加，使用不足时会减少。当缓冲区满时，当最后20个样本的平均缓冲区使用率小于50％时，它会线性增加并减少。我们将最大缓冲区大小限制为2 MB。

附加参数buf_size旨在最大限度地减少总内存使用量。要处理每个Web资源，它需要分配一个大小为buf_size的专用缓冲区。由于加载网页时可能会有很多网络资源，因此如果缓冲区大小很大，则总内存使用率可能较高。通过我们的方法，我们将buf_size设计得很小，同时又足够大以允许下载跟上资源处理。

理想情况下，NRP应该直接适应屏幕上用户感知的内容更改。也就是说，缓冲应该适应Web内容在屏幕上显示的速度。然而，从接收到的数据中检测显示的内容的变化是困难的，并且由于像JavaScript这样的动态内容而造成很高的开销。因此，我们选择网络吞吐量（接收数据的速率）作为显示内容变化的间接但低开销的指标。通过根据吞吐量来控制缓冲器阈值，我们平衡能量成本和网络资源处理的延迟。

为了进一步减少NRP对页面加载时间的影响，我们不将缓冲应用于可能延迟其他资源下载的关键资源。这些关键资源包括主框架的顶层HTML资源（称为Chromium中的主要资源）以及网页的子框架或iframe。这些资源在从网络接收到后立即处理。此外，即使块大小小于buf_threshold，我们也不会缓冲Web资源的最后一块，以防止小的最后一个数据块长时间停留在资源缓冲区中。这是通过检测响应是否完成来实现的，这由浏览器中的网络流解析器执行。因此，它也适用于动态内容。如果响应完成，我们通知Renderer进程立即开始处理所有收到的数据，而不是等待达到buf_threshold。

## 适应性内容绘画

内容绘画在用户体验和能量开销之间进行权衡。尽管高帧速率可以提供非常流畅的用户体验，但它可能会导致GPU和CPU渲染网页时产生高昂的开销，并且与高分辨率结合时会消耗大量能量[33]。如3.2节所示，每个单独的内容涂料可能会在屏幕上引入不同程度的更改。由于大多数内容涂料产生零或非常小的可见屏幕变化，所以多种内容涂料可以聚合在一起以节省能量而不损害用户体验。受此启发，我们将内容绘画设计为适应屏幕上的可见变化，我们将其称为自适应内容绘画（ACP），如下所示。

我们引入了一个名为paint_rate的新参数，该参数限制了内容绘制的速度并动态适应内容更改速度，因此我们可以聚合内容绘画以节省能量，同时保留用户体验。对于给定的paint_rate值，ACP强制实际的内容绘制速率不会超过paint_rate的值（实际速率可能低于paint_rate）。 paint_rate参数的范围从最小绘画率到最大绘画率。 paint_rate的初始值被设置为最小值。当内容快速变化时，paint_rate参数会增加，反之亦然。在合成器线程将更改后的内容绘制到屏幕上后，如果网页继续更改并需要更新屏幕以反映更改，我们将参数线性地增加1以达到最大值。另一方面，当合成器将所有更改传送到屏幕后，当网页显示内容停止改变时，我们将参数降低到最小值。在第5节中，我们将介绍如何检测Chromium中内容更改的速度。

我们将最大绘制速率限制为10帧/秒以平衡能量成本和内容显示的平滑度。我们认为，10帧/秒应该足够平滑，因为1）在页面加载时，网页内容仅部分显示，因此对用户体验的影响很小（特别是在小屏幕智能手机上）;和2）屏幕上的内容变化率通常很低，如3.2节所示。此外，现有的研究[39]表明，延迟高达100毫秒通常是不可感知的。因此，我们认为10帧/秒（即每帧100毫秒）在用户体验和节能之间提供了良好的折衷。当内容变化缓慢时，我们将最小绘制速率设置为2帧/秒以节省更多能量。

理想情况下，ACP技术应量化画框之间的视觉变化以适应内容的变化程度。但是，这样做需要逐个像素比较连续的帧，这会造成大量计算并因此导致高能量成本。因此，我们使用线性增加paint_rate参数的轻量级方法，而无需任何额外的计算成本。

此外，内容绘画应该意识到用户交互。用户触摸屏幕时应使用较高的涂刷率，以确保用户体验顺畅。因此，在我们的实施中，我们还会在用户触摸屏幕时检测用户输入和停止速率限制。

NRP和ACP的两种技术并不完全独立。 NRP批量处理资源并因此减慢内容绘画。与NRP类似，ACP还减少了浏览器进程和渲染器进程之间的IPC数量，以节省能源。

## 应用程序辅助调度

为了更好地利用big.LITTLE架构来节省能源，我们建议利用浏览器的内部知识进行节能高效的调度。我们允许浏览器决定一个线程是应该运行在一个大的还是小的核心上，而不是让OS任务调度程序通过被动地观察线程的负载来做出所有的调度决策。浏览器比OS调度器知道更多有关它们线程的信息，例如线程执行的是什么类型的任务，线程有多重要，线程可以容忍的结束时间，线程的语义以及它们之间的关系。因此，浏览器可能会更好地决定将线程分配给大内核还是小内核。我们称这种技术为应用程序辅助调度（AAS）。

我们设计适用于服务质量（QoS）的AAS技术，因为QoS对用户体验非常重要。 QoS通过浏览器的帧速率估算。 QoS要求根据paint_rate的变化值进行动态调整。如果ACP不工作，则该要求被固定为涂漆速率的最大限制（即10帧/秒）。 AAS首先在小内核上分配与QoS有关的一组线程，并监视当前帧速率。当前帧速率落后于QoS要求时，AAS认为它是QoS的违规。例如，如果paint_rate的值为5，则将QoS定义为在200 ms内绘制每个帧。如果浏览器无法在200 ms内绘制每帧，AAS会判定QoS已被违反，从而迁移大内核相关的线程。当当前帧速率以稳定的方式超过QoS要求时，AAS将这些线程带回到小内核。 AAS在发现当前帧速率与窗口上的QoS要求之间的累积差距不小于阈值时做出这样的决定。因此，在满足QoS的同时，其相应的线程保持在小核心上以节约能量而不损害用户体验。

为了更好地利用小核心来节省更多的能量，我们设计了AAS，以保守的方式将线程从小核心转移到大核心，使用三秒钟的时间窗口，并将线程从大核心移回到小核心核心使用更短的一秒钟时间窗口。

ACP调整paint_rate限制，而AAS仅监视实际帧速率（帧绘制时间）并安排线程以满足限制。由于paint_rate只设置最大涂装速率而不是固定涂装速率，因此AAS技术和帧速率之间没有严格的循环依赖关系。

AAS中的小内核和大内核之间的线程迁移对于所有应用程序都是通用的。 AAS技术动态地改变了QoS相关线程的亲和性，因此不需要将特定线程硬分配给核心。但是，应由AAS管理哪些线程以及如何定义QoS是特定于应用程序的。在第5节中，我们将向我们展示Chromium的哪些线程应用AAS技术。