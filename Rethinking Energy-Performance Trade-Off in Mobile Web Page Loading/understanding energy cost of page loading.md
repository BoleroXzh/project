在本节中，我们将研究Chromium浏览器内部结构和系统调度行为，并确定加载网页时的三个节能低效问题：网络资源处理效率低下，不必要的内容绘制以及未充分利用的小内核。我们还研究其他移动浏览器的行为，并显示它们也具有相同的能源效率低下问题。根据研究结果，我们得出了节能网页加载的一般设计指南。

除非另有说明，否则本节介绍的所有数字均为三星Galaxy S5 SM-G900H big.LITTLE智能手机使用美国Alexa排名前10的网站[2]获得的平均实验结果，包括Google，Facebook，Youtube，雅虎，亚马逊，维基百科，Linkedin，易趣，Twitter和Pinterest。将网站加载到仿真的3G网络上（下载2 Mbps，上传1 Mbps，RTT 120 ms），以进行可重复实验。智能手机的系统总能耗是使用季风功率监视器[29]测得的。

## 无效的Web资源处理

Web资源处理是浏览的主要组件之一，同时还有资源下载和内容绘制。 Web资源处理通常包括HTML和CSS解析，图像解码，Javascript执行以及更新DOM树和图形层。在Chromium中，只要呈现器进程通知了浏览器进程中可用的数据，就会执行上述处理。如图1所示，这两个进程使用共享资源缓冲区交换数据。浏览器进程在套接字处理程序上使用read系统调用来从网络接收网页资源。每个读取系统调用都会将接收到的数据直接写入资源缓冲区，默认情况下最大数据大小为32 KB。在每次读取系统调用时，无论接收到多少数据，浏览器进程都会立即通知呈现器进程开始处理接收到的数据。

尽管立即处理接收到的数据是很自然的，并且可以最大限度地减少页面加载时间，但这不是节能的。原因在于许多读取系统调用会返回少量数据，从而导致Browser进程和Renderer进程之间的大量IPC。在加载10个网站时，99％的读取调用返回的数据块小于3 KB，每次读取返回的平均数据量仅为1.3 KB。加载一个网页时平均有319次阅读电话（每秒62次）。每次读取都可能在浏览器进程和呈现器进程之间导致多个IPC。平均而言，每个网页的IPC总数为871（每秒176）。每个IPC都有一个固定的开销。此外，网络资源处理中还有其他开销。每次处理数据块时，即使数据块很小，Renderer进程也必须经历整个数据渲染管道。特别是对于图像数据，Compositor，Raster Worker和Async Transfer线程中涉及许多图形活动。因此，如第6部分所示，累积的管理费用很高，因此浪费了大量能源，超过系统总能源成本的10％。

## 不必要的内容绘画

![Figure3](/image/Figure3.png)

加载网页时，Chromium会逐步处理Web资源，并不断将部分渲染的显示结果更新到屏幕上。如图1所示，屏幕更新由VSync信号驱动。在接收到VSync信号后，合成器线程通过共享命令和纹理缓冲区将当前渲染图形数据传送到浏览器进程的GPU线程。 GPU线程然后在GPU上执行特定于平台的图形命令以将所有纹理合成为最终图形结果以显示在屏幕上。这种数据渲染和屏幕更新的图形管道称为内容绘制。加载网页时可能会出现许多内容。例如，在加载一个受欢迎的照片分享网站instagram.com时，即使网页没有任何动画，浏览器也可以绘制359种颜色（每秒23.1）。

但是，我们发现大多数情况下，内容绘画会在屏幕上产生非常小的甚至为零的可见变化。为了演示这一观察结果，我们使用Google Chrome的性能测试框架Telemetry [11]记录了每个内容绘画的视觉进度。该工具从渲染引擎收集Paint事件，并计算每个Paint事件更改屏幕的可见像素数量。图3显示了加载instagram.com的结果，包括直方图和CDF。在所有359种涂料中，321种（89％）在屏幕上产生零可见变化。对于前10名网站，也有许多油漆的零或非常小的可见屏幕变化：56％的油漆不会产生任何可见的屏幕变化，62％的油漆产生的可见屏幕变化小于5％ 。这些具有零或非常小的可见屏幕变化的涂料无助于改善用户体验。但是，它们会导致整个图形处理流水线和两个流程之间的IPC发生开销，从而导致不必要的能源成本。高速率内容绘画的这种设计过度优化了性能，而不是节能，必须在移动设备上重新考虑。

## 未充分利用的小核心

![Figure4](/image/Figure4.png)

尽管big.LITTLE旨在节约能源，但我们发现big.LITTLE的节能潜力在铬的情况下还没有充分利用。具体而言，我们发现小核心未充分利用。例如，图4显示了加载instagram.com时Chromium线程的平均执行时间。大多数情况下，线程都是在大内核上执行的。总执行时间的89％在大内核上，但只有11％的执行时间在小内核上。某些线程（如合成器栅格工作线程和异步传输线程）几乎完全（超过95％）在大内核上执行。

低内核利用率低的原因在于操作系统基于负载驱动方法调度线程，该方法偏好性能而不是节能。调度程序试图尽快完成一个线程，而不是节省更多的能量。在对称多核架构上，由于所有的CPU核心都是相同的，这种负载驱动的方法是节能的。如果一个线程可以更快完成任务，CPU可以更快地进入睡眠状态以节省能量[16]。但是，在像big.LITTLE这样的异构多核架构中，尽早完成线程可能不会降低能源成本。如图2所示，与一个大核心相比，一个小核心的每个指令的能耗更低。因此，在较小的内核上运行线程比在大内核上运行需要更长的时间，但消耗的能量更少。因此，只要一个线程可以容忍延迟，就应该在一个小核心上运行。但是，操作系统无法知道线程可以承受多少延迟，因此无法决定是否在较小的内核上运行线程以提高能效。

## 改进指南

上述能源效率低下的问题不是铬专用的。即使没有分析源代码，我们也会观察其他几个移动浏览器加载同一组网页时的行为。通过监控屏幕更新和线程调度行为的数量，我们得出结论：这些移动浏览器基本上与Chromium共享相同的能源效率问题：它们也会进行积极的内容处理和屏幕更新，并依靠OS来执行被动线程调度。

 我们通过从AnDroid SurfaceFlinger转储信息来监控屏幕更新。例如，当加载instagram.com时，Firefox以17.1秒或35.9帧/秒更新其SurfaceView 614次。在基于Chromium的Opera Mobile网络浏览器上也观察到类似的行为。另一种流行的网页浏览器UC浏览器甚至可以每秒固定更新60次，即使内容没有变化。因此，即使内容不变，UC浏览器的平均功耗也达到1755 mW，而其他浏览器（Chromium，Firefox和Opera）的平均功耗仅为475-542 mW。此外，Firefox for Android将其主要线程放在大型核心上：其Gecko渲染引擎线程的84％以及大型核心上60％的Compositor线程。

基于这些研究结果，我们制定了以下降低网页加载能量成本的指导方针：1）网络资源处理应适应下载速度以实现节能; 2）内容绘画应适应屏幕上可见的变化以节省能源; 3）操作系统调度程序应该知道线程的QoS，以做出节能的调度决策。接下来我们将展示如何根据这些设计指南开发节能网页加载技术。